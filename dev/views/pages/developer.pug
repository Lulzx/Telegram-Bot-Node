extends /layouts/default

block vars
  - var page = "developer";
  - const github = "https://github.com/crisbal/Telegram-Bot-Node";
  - const repoName = github.split("/")[4];

block content
  include /includes/navbar
  
  .container
    section.section
      .columns
        .column.is-3
          aside.menu
            p.menu-label Developer's guide
            ul.menu-list
              li: a(href="#firstplugin") Writing your first plugin
              li: a(href="#architecture") Architecture
              li
                a(href="#plugins") Plugins
                ul
                  li: a(href="#staticGetPlugin"): tt static get plugin()
                  li: a(href="#constructor"): tt constructor(obj)
                  li: a(href="#getCommands"): tt get commands()
                  li: a(href="#eventListeners") Event listeners
              li: a(href="#usingAPI") Using the Telegram API
              li: a(href="#proxy") Proxy plugins
              li: a(href="#auth") The Auth helper
        .column.is-9
          section#firstplugin
            h3.title Writing your first plugin
            p.
              Are you looking forward to writing a plugin? The Developer's Guide will help you. Here is a list of steps you could follow:
            ol.list
              li.
                Understand the #[a(href="#plugins") general structure of plugins].
              li.
                Develop your plugin, perhaps using #[a(href=github+"/blob/"+projectbranch+"/src/plugins/Echo.js"): tt Echo.js] as a starting point. Refer often to this guide to learn about available features, and take inspiration from similar plugins.
              li.
                Test your plugin's functionality, both by yourself and with other users.
              li.
                Review our #[a(href="#bestpractices") best practices] and apply them to your plugin.
              li
                | If you wish, submit it into the main repository!
                ol.list
                  li.
                    Fork #[a(href=github) our repository] on GitHub.
                  li.
                    Commit your changes, taking care to follow our #[a(href=github+"/blob/"+projectbranch+"/CONTRIBUTING.md") coding standards] which dictate rules on code formatting and commit messages.
                  li.
                    Open a #[a(href=github+"/pulls") pull request].
            br
          section#architecture
            h3.title Architecture
            p
              | This is an overview of the logic flow of messages:
            figure.has-text-centered
              a(href=root+"assets/images/Message_diagram.png", alt="Message flow diagram", title="Open this image in a new tab", target="_blank")
                img(src=root+"assets/images/Message_diagram.png")
            p.
              PluginManager receives Telegram messages, and passes them to the proxy plugins for inspection. If the message is approved by all proxies, it is sent to all plugins, which may decide to reply with a text, picture and so on by interacting directly with the Telegram API.
          section#plugins
            h3.title Plugins
            p.
              In #{projectname}, plugins are #[strong classes that react to specific events from the Telegram API].
            p.
              The general structure is:
            pre: code.js.
              // File: src/plugins/MyPlugin.js
              const Plugin = require("../Plugin");

              module.exports = class MyPlugin extends Plugin {
                // Information about your plugin.
                static get plugin() {
                  return {
                    name: "MyPlugin",
                    description: "It does things.",
                    help: "Try saying 'Hello!', or using the /hello command."
                  }
                }

                // Optional: initialize the plugin.
                constructor(obj) {
                  super(obj);

                  /* ... */
                }

                // Optional: stop the plugin.
                stop() {
                  foo.stop();
                }

                // An object, mapping commands to their handlers.
                // Handlers can return a string, representing a text reply.
                get commands() {
                  return {
                    hello: ({args, message}) => {
                      // Args is an array of arguments passed by the user (eg. `/foo bar` would have args = ["bar"])
                      // Message is the message that triggered the handler

                      return "Heyo!";
                  };
                }

                // Alternatively, you can use the more verbose onCommand listener.
                onCommand({message, command, args}) {
                  if (command === "hello") {
                    this.sendMessage(message.chat.id, "Heyo!");
                  }
                }

                // Called when a message is received.
                onText({message}) {
                  if (message === "Hello!") {
                    this.sendMessage(message.chat.id, "Hi!");
                  }
                }

                onPhoto({message}) {
                  /* ... */
                }

                /* ... */
              }
            p.
              As you can see, it is a class that extends Plugin (from #[tt src/Plugin.js]). The metadata is given through #[tt static get plugin()], which #[strong must] be present.
            blockquote#staticGetPlugin
              | Every plugin must have #[tt static get plugin()], which returns an object. At a minimum, it contains:
              ul.list
                li #[tt name]: the plugin's name
                li #[tt description]: a short description (shown in the list of plugins)
                li #[tt help]: a help text (shown in #[kbd /help PluginName])
              | It can include additional properties, which we'll explain later:
              ul.list
                li #[tt isProxy], which says whether this plugin has proxy capabilities or not (default: false)
                li #[tt isHidden], which says whether this plugin is hidden from #[kbd /help] or not (default: false)
            p.
              It optionally features a #[tt constructor], to give you access to rarely-used objects:
            blockquote#constructor
              | #[tt constructor] gets passed a single variable (usually called #[tt obj]), which contains the objects needed to initialize the plugin. They are:
              ul.list
                li config: the bot's configuration
                li auth: an instance of the Auth helper, documented later
              | There are also some properties you shouldn't need:
              ul.list
                li db: the plugin database loaded from disk (you shouldn't need it, it's in #[tt this.db])
                li blacklist: same as above, but with the blacklist (#[tt this.blacklist])
                li emitter: the emitter from PluginManager (can be accessed with #[tt onText], #[tt onMessage] and so on)
                li bot: the TelegramBot object from #[tt node-telegram-bot-api]
            p.
              Most of the time, it features a list of commands, in a special shorthand form (#[tt command:&nbsp;({message,&nbsp;args})&nbsp;=&gt;&nbsp;reply]) that allows for concise code.
            blockquote#getCommands
              | To use the commands shorthand, add a #[tt commands] getter:
              pre: code.js.
                get commands() {
                  return {
                    commandName: ({message, args}) => {
                      // Your code here
                    },
                    ping: ({message, args}) => "Pong!"                  
                  }
                }
              | It returns an object, where each key is the command name and the value is the handler. It takes an object with #[tt message] being the Telegram message, and #[tt args] being an array of arguments.
              blockquote
                strong Note that #[tt args] is just "the rest of the message, split with spaces", so it can have unpredictable results when you expect strings.
                br
                | For instance, if the original message is #[kbd /echo Hello world!], #[tt args] will be #[tt ["Hello", "world!"]] and #[strong not] #[tt ["Hello world!"]].
              | If the handler returns a string, it is sent to the chat where the message came from. This can be useful to avoid going through the cumbersome Telegram API. For example:
              pre: code.js.
                get commands() {
                  return {
                    reverseText: ({message, args}) => {
                      const text = args.join(" "); // Because there may be multiple words
                      if (text === "")
                        return "Please give me some text to reverse.";
                      const reversed = text.split("").reverse().join(""); // https://stackoverflow.com/a/959004
                      return reversed;
                    }
                  }
                }
            p.
              It also features one or more #[strong event listeners], functions that react to events.
            blockquote#eventListeners
              | An example of event listener is:
              pre: code.js.
                onText({message}) {
                  // Your code here
                }
              p They are functions that are invoked whenever a specific event happens. They take an object argument with the property #[tt message]; the return value is ignored.
              p You can reply to the message using the Telegram API methods, documented below.
              p You can find a list of event listeners in #[tt src/Plugins.js]; the general rule is that the listener takes the name of the event (text -> onText, photo -> onPhoto and so on).
          section#usingAPI
            h3.title Using the Telegram API
            p.
              #{projectname} exposes the Telegram API through #[tt: a(href="https://npmjs.com/package/node-telegram-bot-api") node-telegram-bot-api], the methods of which are bound on the Plugin instance. In short, this means that inside a plugin you can simply call #[tt this.sendMessage(...)] and it will work as expected.
            blockquote.
              Note that in #[tt function() { }] blocks, #[tt this] #[strong does not] point to the Plugin instance, so #[tt this.sendMessage] won't work as expected. You should replace them with arrow functions if you wish to use #[tt this].
            p.
              Refer to the #[a(href="https://github.com/yagop/node-telegram-bot-api/blob/release/doc/api.md") NTBA reference] or its #[a(href="https://github.com/yagop/node-telegram-bot-api#usage") documentation] for extended information on how to use it. Here are some of the most common cases:
            pre: code.js.
              // Responding to a message
              onText({message}) {
                if (message.text === "Hello, bot!") {
                  this.sendMessage(message.chat.id, "Hello, user!");
                }
              }

              // Italic/bold text
              onText({message}) {
                this.sendMessage(message.chat.id, "__Italic__, **bold**", {parse_mode: "Markdown"});
                this.sendMessage(message.chat.id, "&lt;i&gt;Italic&lt;/i&gt;, &lt;b&gt;bold&lt;/b&gt;", {parse_mode: "HTML"});
              }

              // Sending a picture
              onText({message}) {
                this.sendPhoto(message.chat.id, "/home/john/Pictures/paveldurov.jpg", {caption: "This is Pavel Durov."});
              }
            blockquote.
              Note that #[tt sendMessage] (like all send* functions) takes two arguments, the chat ID (or the user ID, if they already initiated a conversation with the bot) and the text.
          section#proxy
            h3.title Proxy plugins
            p.
              #{projectname} supports #[i proxy plugins], i.e. plugins that can approve or reject messages. Approved messages keep going through the bot and plugins; rejected messages are dropped.
            p.
              To configure a plugin as a proxy, simply set #[tt isProxy: true] in #[tt static get plugin()] and implement a #[tt proxy(eventName, message)] method. It will receive every message, returning a rejected Promise (#[tt Promise.reject]) if the message is rejected, and anything else otherwise.
          section#auth
            h3.title The Auth helper
            p.
              Sometimes, you may want to restrict the usage of a command to mods, or viceversa you may want to apply a command differently for normal users and admins (eg. prevent admins from being kicked). For this, you can use the Auth helper, which has methods to determine whether a user is a mod or an admin in a specific chat. You can get it via the constructor:
            pre: code.js.
              constructor(obj) {
                super(obj);

                this.auth = obj.auth;
              }

              onText({message}) {
                if (this.auth.isAdmin(message.chat.id, message.from.id)) {
                  this.sendMessage(message.chat.id, "You are an admin!");
                } else {
                  this.sendMessage(message.chat.id, "You are not an admin, sorry.");                
                }
              }
            p.
              It exposes the methods #[tt isMod(chatID, userID)] and #[tt isAdmin(chatID, userID)] to determine whether an user is #[strong at least] a mod or an admin in a chat, #[tt isGlobalAdmin(userID)] to determine if the user is a global admin (i.e. a founder) per #[tt config.json], and #[tt getMods(chatID)]/#[tt getAdmins(chatID)] to get an array of mod and admin user IDs respectively.
          section#bestpractices
            h3.title Best practices
            p.
              This is a list of guidelines that plugins should follow in order to be enjoyed by users.
            ul.list
              li.
                Each plugin exists to fulfill one or more needs, be it a need for fun or for a tool. The plugin should fulfill the users' needs with the #[strong minimum number of steps], and possibly #[strong short interactions].
              li.
                Being able to fulfill a task in few steps is part of #[strong keeping it simple]. This principle also means hiding the complexities of a system from the user, exposing a simple interface instead.
              li.
                #[strong Use structured input (buttons) when possible]. This usually makes it as easy as possible to interact with the bot, since it reduces the possibilities to make mistakes.
              li.
                Enforce #[strong authorization checks]. This can be as trivial as not letting a mod kick an admin, but can also be more subtle: for instance, if an action takes two or more steps, it shouldn't be possible for an user to initiate the action and another to continue it.
              li
                | #[strong Provide feedback] for user's actions. For instance, if you're writing the Set plugin, you might want to send the user a confirmation:
                blockquote.
                  #[strong User]: /set Hello Hey there!
                  #[br]
                  #[strong Bot]: Set Hello =&gt; Hey there!
                p Note that in this case, we're not just providing a confirmation, but we're repeating part of the input to confirm the action was understood correctly.
                p On the other hand, you #[strong shouldn't provide redundant feedback]. For instance, if you ask the bot to change the chat title, Telegram will already display a notification, so you shouldn't send an additional message:
                blockquote.
                  #[strong User]: /settitle My favourite chat
                  #[br]
                  #[i Bot changed the chat title to "My favourite chat".]
              li
                | An important part of providing feedback is #[strong handling errors] and informing the user of them. For instance, if you're writing a plugin to change the chat's title, consider the possibility that it doesn't work due to the bot not being an admin:
                blockquote.
                  #[strong User]: /settitle My favourite chat
                  #[br]
                  #[strong Bot]: Couldn't set the chat title: not a chat admin.
                | Note that for Telegram API methods such as #[tt .setChatTitle], this is achieved with promises with a #[tt .catch(error =&gt; {...})] clause.
              li
                | #[strong Use #[tt this.log] sparingly] instead of #[tt console.log]. This allows the bot's owner to stay aware of what their bot is doing, without being overwhelmed with messages. Choose levels accordingly: being unable to kick an user should be logged with #[tt this.log.error], but the user running a query on your plugin (eg. #[kbd /google telegram bots]) is worthy of #[tt this.log.debug] at most.
              li.
                If you use a multi-step process, #[strong provide a way out]. Users may change their minds or decide they "started with the wrong foot"; they should be able to undo the action, and not be stuck in the process.
            small.
              Sources: Microsoft's #[a(href="https://docs.microsoft.com/en-us/bot-framework/bot-design-principles") Principles of bot design], Intercom's #[a(href="https://blog.intercom.com/principles-bot-design/") principles of bot design], Facebook's #[a(href="https://developers.facebook.com/docs/messenger-platform/introduction/general-best-practices") Design best practices].